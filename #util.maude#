*** adapted from Max Schafer ***

fmod REWRITING is
  protecting META-LEVEL .

  sort Rewriting .

  op rewriting : Qid Context TermList Term Substitution -> Rewriting [ctor] .
  
  op getRewriterName : Rewriting -> Qid .
  op getContext : Rewriting -> Qid .
  op getResults : Rewriting -> TermList .
  op getSubstitution : Rewriting -> Substitution .
  op getOriginalTerm : Rewriting -> Term .
  
  var Q : Qid .
  var Ctxt : Context .
  var TL : TermList .
  var Trm : Term .
  var Subst : Substitution .
  
  eq getRewriterName(rewriting(Q, Ctxt, TL, Trm, Subst)) = Q .
  eq getContext(rewriting(Q, Ctxt, TL, Trm, Subst)) = Ctxt .
  eq getResults(rewriting(Q, Ctxt, TL, Trm ,Subst)) = TL .
  eq getSubstitution(rewriting(Q, Ctxt, TL, Trm, Subst)) = Subst .
  eq getOriginalTerm(rewriting(Q, Ctxt, TL, Trm, Subst)) = Trm .

endfm

view Rewriting from TRIV to REWRITING is
  sort Elt to Rewriting .
endv

fmod Util is

  including META-LEVEL .
  including META-STRATEGY .
  including META-MODULE .

  sorts Derivation DerivationList Derivation? DerivT .
  subsort Derivation < Derivation? .
  subsort Derivation < DerivationList .
  subsort DerivT < Term  .
  
  protecting SET{Rewriting} * (sort Set{Rewriting} to RewritingSet) .

*** finds out whether and how a term can be rewritten using any among a list
***  of inference rules and operators (where rewriting a term t using an
***  operator o means that the term o(t) reduces to some term whose outermost
***  functor is not o)

  op findRewrites : Term Qid QidList -> RewritingSet .
  op findRewritesForRule : Term Qid Qid Nat -> RewritingSet .
  op extractRewriting : Term Qid Result4Tuple -> RewritingSet .	
  op extractTermList : Term -> TermList .
  op getElements : Term -> Term .
  op wow : -> Term .
  op wow1 : -> Term .
  op nah : -> Term .
  op error : -> Term .
  op nothing : -> Term .


  vars Trm Trm1 Trm2 Trm3 Trm4 T1 T2 T3 T4 input B TEST Top OrigTrm finalTrm : Term .
  var Tp : Type .
  var Attrs : AttrSet .
  var M M1 M2 Q Q1 Q2 Q3 : Qid .
  var N K : Nat .
  var V V1 V2 : Variable .
  var C : Constant .
  var TL : TermList .
  var Rewr op op1 ss : Qid .
  var QL RewrList : QidList .
  var Reing : Rewriting .
  var ReingList : RewritingSet .
  var Ctxt Ctxt1 : Context .
  vars TL1 TL2 : TermList .
  var Subst : Substitution .
  var Mod : Module .
  var Rls : RuleSet .
  var Rle : Rule .
  var DT1 DT2 : DerivT .
  var rp : ResultPair .
  var cnst cnst1 cnst2 cnst3 : Constant .
  var sub : Substitution .
  var con : Context .
  var nct : NeCTermList .
  var mp : MatchPair .
  var S1 S2 : Substitution .
  var Tr Tr1 Tr2 : Trace .
  var TrL : TraceList .
  var TrSt TrSt1 TrSt2 : TraceStep .
  
  op ket : Term -> Term .
  op getRewrites : RewritingSet Term -> Term .
  op getRewrites1 : RewritingSet Term -> Term .
  op getFormula : Term -> Term .
  
*** getRewrites applies rules and gets rewrites of a subatomic formula,
*** then compares the interpretation of the rewrite with the standard formula conclusion
  
  
  op getReplacement : MatchPair Term -> Term .
  eq getReplacement ( { sub , op[ TL, con ] } , T1 ) = op [ TL , getReplacement ( { sub , con } , T1 ) ] .
  eq getReplacement ( { Trm1 <- Trm2 , [] } , T1 ) = replace-conc( Trm2 , T1 ) . 
  
  op replace-conc : Term Term -> Term .
  eq replace-conc( Trm1, '_>`[_`]>_[ T1 , Q , T2 ] ) = test('_>`[_`]>_[ Trm1 , Q , T2 ]) . 
  
  op peak : TermList -> Term .
  eq peak ( ( Trm, TL ) ) = Trm .
  
  op remove_top : TermList -> Term .
  eq remove_top ( ( Trm, TL ) ) = TL .
  
  op replace : Term Term Term  -> Term .
  op replace1 : Term Term Term -> Term .
  op replace2 : Term Term Term -> Term .
  op replace10 : Term Term Term -> Term .

 eq replace ( Trm , empty , '_>`[_`]>_[ Trm2 , Q , Trm3 ] ) =
	if getTerm ( metaReduce(upModule('S-INT,false),'I[Trm]) ) == Trm2 then
		replace-conc( Trm, '_>`[_`]>_[ Trm2 , Q , Trm3 ] )
	else
		'na
	fi .	
	
  eq replace ( Trm , empty , Trm2 ) = Trm .
  
  eq replace ( Trm , ( Top , TL ) , Trm2 ) =
	replace(getReplacement(metaXmatch(  upModule('S-Inf,false),
										'S:Structure, Trm,
										getTerm ( metaReduce(upModule('S-INT,false),'I['S:Structure]) ) = getFormula(Top),
										0,unbounded,0 )
							,Top)
			,TL, Trm2) .

  op reassemble : Substitution -> TermList .
  eq reassemble ( 'S:Structure <- Trm1 ; V1 <- Q ; 'T:DerivStructure <- Trm2 ) = '_>`[_`]>_[Trm1 , Q , Trm2] .
	
  op extractContext : Context -> Term .
  eq extractContext ( '_>`[_`]>_[ Trm1 , Q , con ] ) = '_>`[_`]>_[Trm1 , Q , extractContext(con) ] .
  eq extractContext ( '_>`[_`]>_[ con , Q , Trm2 ] ) = '_>`[_`]>_[extractContext(con) , Q , Trm2 ] .
  eq extractContext ( op [ TL , con ] ) = op [ TL , extractContext ( con ) ] .
  eq extractContext ( [] ) = 'none.Atom .
  
  
  op extractSubstitution : Substitution -> Term .
  eq extractSubstitution ( V <- Trm ) = Trm .
	
  op manyMatches : Term Context Nat -> Nat .
  eq manyMatches( Trm , con , N ) =
	if metaXmatch( upModule('S-Inf , false ) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] , extractContext(con) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] = Trm , 0 , unbounded, N ) =/= noMatch then
		manyMatches( Trm , getContext(metaXmatch( upModule('S-Inf , false ) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] , extractContext(con) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] = Trm , 0 , unbounded, N )) , N + 1)
	else
		N
	fi .
	
  op duplicate : Term Nat -> TermList .
  eq duplicate( Trm , 0 ) = Trm .
  eq duplicate( Trm , N ) = Trm , duplicate( Trm , sd ( N , 1 ) ) .

  op ket2 : Term Nat -> Term .
  eq ket2 ( '_>`[_`]>_[ Trm1 , Q , Trm2 ] , N ) = ket2( Trm1 , N ) .
  eq ket2 ( Trm , N ) =
	if metaXmatch( upModule('S-Inf , false ) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] , Trm , nil , 0 , unbounded, N ) =/= noMatch then
		duplicate( reassemble(getSubstitution(metaXmatch( upModule('S-Inf , false ) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] , Trm , nil , 0 , unbounded, N ))),
				   manyMatches(reassemble(getSubstitution(metaXmatch( upModule('S-Inf , false ) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] , Trm , nil , 0 , unbounded, N ))),
							   getContext(metaXmatch( upModule('S-Inf , false ) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] , Trm , nil , 0 , unbounded, N )),
							   0)),		
		ket2(Trm, N + 1 )
	else
		empty
	fi .

  op inn : Term TermList -> Bool .
  eq inn(Trm, op [Trm1,TL]) =
		if inn(Trm,Trm1) then true else inn(Trm,TL) fi .
  eq inn(Trm , Trm1) =
		if Trm == Trm1 then true else false fi .
  eq inn(Trm, (Trm1,TL)) =
		if inn(Trm,Trm1) then true else inn(Trm,TL) fi .
  eq inn(Trm,empty) = false .
	
  op ket3 : Term Nat -> Term .
  eq ket3 ( '_>`[_`]>_[ Trm1 , Q , Trm2 ] , N ) = ket3( Trm1 , N ) .
  eq ket3 ( Trm , N ) = 
	if metaXmatch( upModule('S-Inf , false ) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] , Trm , nil , 0 , unbounded, 0 ) =/= noMatch then
		if not inn( 'none.Atom , reassemble(getSubstitution(metaXmatch( upModule('S-Inf , false ) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] , Trm , nil , 0 , unbounded, 0 )))) then
			reassemble(getSubstitution(metaXmatch( upModule('S-Inf , false ) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] , Trm , nil , 0 , unbounded, 0 ))),
			ket3(extractContext(getContext(metaXmatch( upModule('S-Inf , false ) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] , Trm , nil , 0 , unbounded, 0 ))), 0)
		else
			ket3(extractContext(getContext(metaXmatch( upModule('S-Inf , false ) , '_>`[_`]>_['S:Structure, 'Q:Qid, 'T:DerivStructure] , Trm , nil , 0 , unbounded, 0 ))), 0)
		fi
	else
		empty
	fi .
	
*** reduce in S-Inf : gnf(upTerm([{[- c,- d],[- c,- d]},{c >['c-down]> [c,c],d >['c-down]> [d,d]} >['m]> [{c,d},{c,d}]] >['equality]> [{c,d},[{[- c,- d],[- c,- d]},{c,d}] >['s]> {[- c,- d],[- c,[- d,{c,d}]]}] >['s]> {[- c,[- d,{c,d}] >['s]> {c,[d,- d]}],[- c,[- d,{c,d}] >['s]> {c,[d,- d]}] >['s]> {[c,- c],[d,- d]}}) ) .
  eq ket ( '_>`[_`]>_[ Trm2 , Q , Trm3 ] ) = '_>`[_`]>_[ Trm2 , Q , Trm3 ] .
  eq ket ( op['_>`[_`]>_[ Trm2 , Q , Trm3 ]] ) =  ket('_>`[_`]>_[ Trm2 , Q , Trm3 ]) .
  eq ket ( op [ cnst , TL1 ] ) = ket ( op [ TL1 ] ) .
  eq ket ( op [ Trm1 , TL1 ] ) = ket ( Trm1 ) , ket ( op [ TL1 ] ) .
  eq ket ( Trm ) = empty .
  eq ket ( op [ empty ] ) = empty .

  eq getRewrites ( (rewriting( Q , Ctxt, Trm1 , OrigTrm, Subst) , ReingList) , Trm2 ) = 
	if getTerm ( metaReduce ( upModule( 'S-INT , false ) , 'I[ Trm1 ] ) ) == flatten(Trm2) then
		Trm1 ***replace( Trm1 , ket3 ( Trm2 , 0 ) , Trm2 )
	else
		getRewrites( ReingList , Trm2 )
	fi .
	
  eq getRewrites( empty, Trm2 ) = error .
	
  ***[- d,{c,d}] >['s]> {c,[d,- d]}
  ***[- d,{c,d}] >['s]> {c,[d,- d]}
  ***[- d,{c,d}] >['s]> {c,[d,- d]}
  ***[- d,{c,d}] >['s]> {c,[d,- d]}
  ***{[- c,[- d,{c,d}] >['s]> {c,[d,- d]}],[- c,[- d,{c,d}] >['s]> {c,[d,- d]}] >['s]> {[c,- c],[d,- d]}}
  
  eq getRewrites1 ( (rewriting( Q , Ctxt, Trm1, OrigTrm, Subst ) , ReingList) , Trm2 ) = 
	if getTerm ( metaReduce ( upModule( 'S-INT , false ) , 'I[ Trm1 ] ) ) == flatten(getFormula(Trm2)) then
		replace1( Trm1 , ket3 ( Trm2 , 0 ) , Trm2 )
	else
		getRewrites1( ReingList , Trm2 )
	fi .
	
  eq getRewrites1( empty, Trm2 ) = error .
  
 ceq gnf1 ( Trm ) = getTerm ( metaReduce ( upModule( 'S-REP , false ) , 'R[ Trm ] ) ) 
	if flat ( Trm ) .
  ceq gnf1 ( op [ Trm1 , Trm2 ] ) = op [ gnf1(Trm1) , gnf1(Trm2) ]
	if op =/= '_>`[_`]>_ and Trm2 =/= empty .
  ceq gnf1 ( op [ Trm1 , TL ] ) = op [ gnf1(Trm1) , gnf1(op[TL]) ]
	if op =/= '_>`[_`]>_ and TL =/= empty .
  ***eq gnf1 ( '_>`[_`]>_[ Trm1 , ''equality.Sort , Trm2 ] ) = '_>`[_`]>_[ gnf1(Trm1) , ''equality.Sort , gnf1(Trm2) ].
  eq gnf1 ( '_>`[_`]>_[ Trm1 , Q , Trm2 ] ) = test2 ('_>`[_`]>_[ gnf1(Trm1) , Q , gnf1(Trm2) ]) .
  eq gnf1 ( Trm ) = getTerm ( metaReduce ( upModule( 'S-REP , false ) , 'R[ Trm ] ) ) .


*** gnf takes proof trees and converts them into their subatomic form
  op gn : Term -> Term .
  op gnf : Term -> Term .
  op gnf1 : Term -> Term .
  op gnf2 : Term -> Term .
  op gnf3 : Term -> Term .
  op gnf4 : Term -> Term .
  op gnf5 : Term -> Term .
  op gnf6 : Term -> Term .
  op gnf7 : Term -> Term .
  
  ceq gnf ( Trm ) = getTerm ( metaReduce ( upModule( 'S-REP , false ) , 'R[ Trm ] ) ) 
	if flat ( Trm ) .
  
  ceq gnf ( op [ Trm1 , Trm2 ] ) = op [ gnf(Trm1) , gnf(Trm2) ]
	if op =/= '_>`[_`]>_ and Trm2 =/= empty .
	
  ceq gnf ( op [ Trm1 , TL ] ) = op [ gnf (Trm1) , gnf(op[TL]) ]
	if op =/= '_>`[_`]>_ and TL =/= empty .
  
  eq gnf ( '_>`[_`]>_[ Trm1 , ''equality.Sort , Trm2 ] ) = '_>`[_`]>_[ gnf1(Trm1) , ''equality.Sort , gnf1(Trm2) ].
 
  eq gnf ( '_>`[_`]>_[ Trm1 , Q , Trm2 ] ) = test2 ('_>`[_`]>_[ gnf(Trm1) , Q , gnf(Trm2) ]) .
  eq gnf ( Trm ) = getTerm ( metaReduce ( upModule( 'S-REP , false ) , 'R[ Trm ] ) ) .
  
 
  
  
    op test2 : Term -> Term .
	ceq test2 ( '_>`[_`]>_[ Trm1 , Q , Trm2 ] ) = '_>`[_`]>_[ Trm1 ,
															  getRewriterName(getRe(findRewrites ( flatten(getTopFormula(Trm1)) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ) , flatten(getFormula(Trm2)))),
															  Trm2 ]
		if getRe(findRewrites ( flatten(getTopFormula(Trm1)) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ) , flatten(getFormula(Trm2))) =/= empty .

	ceq test2( '_>`[_`]>_[ Trm1 , Q , Trm2 ] ) = '_>`[_`]>_[ Trm1 ,
															getRewriterName(getRe(
															  findRewrites ( flatten(getTopFormula(Trm1)) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ),
															  interpret(getFormula(Trm2)), 0)),
															getResults(getRe(
															  findRewrites ( flatten(getTopFormula(Trm1)) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ),
															  interpret(getFormula(Trm2)), 0)) ]
															 
	***getResults(getRe(
		***		  findRewrites ( flatten(getTopFormula(Trm1)) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ),
			***	  interpret(getFormula(Trm2)), 0))
			
	*** do thing similar to replace thing done before...
															  
															  
		if findRewrites ( flatten(getTopFormula(Trm1)) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ) =/= empty .
															  
	ceq test2( '_>`[_`]>_[ Trm1 , Q , Trm2 ] ) = '_>`[_`]>_[ getResults(getRe(
															  findRewrites ( flatten(getFormula(Trm2)) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ),
															  interpret(Trm1), 0)) ,
															getRewriterName(getRe(
															  findRewrites ( flatten(getFormula(Trm2)) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ),
															  interpret(Trm1), 0)),
															 Trm2 ]
		if findRewrites ( flatten(getFormula(Trm2)) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ) =/= empty .

	eq test2 ( '_>`[_`]>_[ Trm1 , Q , Trm2 ] ) = 'd .
		
	eq test1 ( Trm1 ) = Trm1 .
	
  op interpret : Term -> Term .
  eq interpret( Trm ) = flatten(getTerm(metaReduce(upModule( 'S-INT , false ), 'I[getFormula(Trm)]))) .
  

  op binop : Term -> Bool .
  eq binop ( op [ Trm1 ] ) = false .
  eq binop ( cnst ) = false .
  eq binop ( op [ Trm1 , TL ] ) = true .
  
  op isflat : Term -> Bool .
  op flat : Term -> Bool .
  ceq flat ( op [ TL ] ) = isflat ( TL ) if op =/= '_>`[_`]>_ .
  eq isflat ( ( Trm, TL ) ) = if binop ( Trm ) then false else isflat(TL) fi .
  eq isflat ( empty ) = true .
  
  op test : Term -> Term .
  eq test ( '_>`[_`]>_[ Trm1 , Q , Trm2 ] ) =
	if Q == ''equality.Sort then
		if 'true.Bool  == getTerm( metaReduce ( upModule ( 'EQQ , false ) , 'equality[getTerm(metaReduce(upModule( 'S-INT , false ), 'I[getTopFormula(Trm1)])) , getFormula(Trm2)] ) ) then
			'_>`[_`]>_[ Trm1 , Q , replace(getTopFormula(Trm1),ket3(Trm2,0), Trm2) ]
		else
			'na
		fi 
	else if getRewrites ( findRewrites ( getTopFormula ( Trm1 ) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ) , getFormula ( Trm2 ) ) =/= error then
		'_>`[_`]>_[ Trm1 , Q , getRewrites ( findRewrites ( getTopFormula ( Trm1 ) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ) , Trm2 ) ]
	else
		test ( '_>`[_`]>_[getRewrites ( findRewrites ( getTerm ( metaReduce ( upModule( 'S-REP , false ) , 'R[ getFormula ( Trm2 ) ] ) ) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ) ,
			getTerm ( metaReduce ( upModule( 'S-INT , false ) , 'I[ Trm1 ] ) ) ) , Q , Trm2] ) 
	fi fi .
	eq test ( Trm1 ) = Trm1 .
	
	op test1 : Term -> Term .
	eq test1 ( '_>`[_`]>_[ Trm1 , Q , Trm2 ] ) =
		if Q == ''equality.Sort then
			if 'true.Bool  == getTerm( metaReduce ( upModule ( 'EQQ , false ) , 'equality[getTerm(metaReduce(upModule( 'S-INT , false ), 'I[getTopFormula(Trm1)])) , getFormula(Trm2)] ) ) then
				replace10(getTopFormula(Trm1),ket3(Trm2,0), Trm2) ***'_>`[_`]>_[ Trm1 , Q , replace(getTopFormula(Trm1),ket3(Trm2,0), Trm2) ]
			else
				'na
			fi 
		else if getRewrites ( findRewrites ( getTopFormula ( Trm1 ) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ) , getFormula ( Trm2 ) ) =/= error then
			getRewrites1 ( findRewrites ( getTopFormula ( Trm1 ) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ) , Trm2 ) ***'_>`[_`]>_[ Trm1 , Q , getRewrites ( findRewrites ( getTopFormula ( Trm1 ) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ) , Trm2 ) ]
		else
			test ( '_>`[_`]>_[getRewrites ( findRewrites ( getTerm ( metaReduce ( upModule( 'S-REP , false ) , 'R[ getFormula ( Trm2 ) ] ) ) , 'SAM-Meta , 'a-up 'a-down 'conj-down 'conj-d 'disj-up 'm 'ac 'acc ) ,
				getTerm ( metaReduce ( upModule( 'S-INT , false ) , 'I[ Trm1 ] ) ) ) , Q , Trm2] ) 
		fi fi .
		eq test1 ( Trm1 ) = Trm1 .

  op flatten : Term -> Term .
  eq flatten( Trm ) = getTerm( metaReduce ( upModule( 'SAM-Meta , false ) , Trm ) ) .
 
  op getFormula : Term -> Term .
  eq getFormula( '_>`[_`]>_[ Trm1 , Q , Trm2 ] ) = getFormula(Trm1) . 
  eq getFormula( op [ Trm , TL ] ) = flatten ( op [ getFormula( Trm ) , getFormula( TL ) ] ) .
  eq getFormula( (Trm , empty ) ) = Trm .
  eq getFormula( (Trm, TL) ) = getFormula(Trm) , getFormula( TL ) .
  eq getFormula( empty ) = empty .
  
  op getTopFormula : Term -> Term .
  eq getTopFormula( '_>`[_`]>_[ Trm1 , Q , Trm2 ] ) = getTopFormula(Trm2) . 
  eq getTopFormula( op [ Trm , TL ] ) = flatten ( op [ getTopFormula( Trm ) , getTopFormula( TL ) ] ) .
  eq getTopFormula( (Trm , empty ) ) = Trm .
  eq getTopFormula( (Trm, TL) ) = getTopFormula(Trm) , getTopFormula( TL ) .
  eq getTopFormula( empty ) = empty .
  
*** Finds rewrites for term e.g. a ground term like _`[_`]('`[_`,_`],_`,_('a.Atom,'b.Atom))
*** with M = 'KSg-Meta, and then it splits QidList of the selected rules, into two seperate variables
*** that is, into Rewr and RewrList, and then from that it splits the original function into two, and
*** finds rewrites for just one rule, it does this recursively.

  eq findRewrites(Trm, M, (Rewr RewrList)) =  findRewritesForRule(Trm, M, Rewr, 0) , findRewrites(Trm, M, RewrList) .
  eq findRewrites(Trm, M, nil) = empty .

*** metaXapply( the module, the term, the rule, none, 0, the bound, N is the increment, e.g. ignore successful matches )
*** So metaXapply reduces the term in the module, and then applies the rule to the reduced term.
*** This is then repeated with incrementing N, until all possible rewrites have been found.
*** For each rewrite of the term with a rule, the rewrite is extracted with extractRewriting.
  
   eq findRewritesForRule(Trm, M, Q, N) = 
	if  metaXapply([M], Trm, Q, none, 0, unbounded, N) == failure
	then empty
	else extractRewriting(Trm, Q, metaXapply([M], Trm, Q, none, 0, unbounded, N)),
	     findRewritesForRule(Trm, M, Q, N + 1)
    fi .
  
*** Trm is the original term, Q is the rule, Trm2 is the term after being rewritten,
*** Tp is the type, Subst is the substitution, Ctxt is the context

*** I add  'or Ctxt =/= []', this makes it so rewrites are only found for when the context
*** is empty, that is, they are only found for the very outer level


*** gets the formulae of a ground term without the connective stuff
  eq getElements( op [TL]) = TL .
  
*** These equations check if a formula is a subformula of another formula
  op contains : Term TermList -> Bool .
  eq contains(Trm, []) = false .
  eq contains(Trm, Trm2) = (Trm == Trm2) .
  eq contains(Trm, (Trm2, TL1)) = if Trm == Trm2 then true else contains(Trm, TL1) fi .

  eq extractRewriting(OrigTrm, Q, {Trm2, Tp, Subst, Ctxt}) =
    if Q == 'tt-norm then
		if extractTermList(Trm2) =/= 'tt.Unit then
    		findRewritesForRule(Trm2, 'KSg-Meta, 'tt-norm, 0)
    	else
    		rewriting(Q, Ctxt, extractTermList(Trm2), OrigTrm, Subst)
    	fi
    else
    	if Q == 'tt-elim then
    		if contains('tt.Unit, getElements(extractTermList(Trm2))) then
    			findRewritesForRule(Trm2, 'KSg-Meta, 'tt-elim, 0)
    		else
    			rewriting(Q, Ctxt, extractTermList(Trm2), OrigTrm, Subst)
    		fi
    	else
    		if OrigTrm == Trm2 then ***or Ctxt =/= [] then
    			empty
    		else
    			rewriting(Q, Ctxt, extractTermList(Trm2), OrigTrm, Subst)
    		fi
    	fi
    fi .

  eq extractTermList(Q[TL]) =
	if Q == '_;_ then TL else Q[TL] fi .

*** C is constant, V is variable
  eq extractTermList(C) = C .
  eq extractTermList(V) = V .
  

  
  *** extracts binding
  op extractBinding : Variable Substitution -> Term .
  eq extractBinding(V, V <- Trm ; Subst) = Trm .
  
  op extractBinding : Substitution -> Term .
  eq extractBinding( V <- Trm ) = Trm .
  
  op extractBinding : MatchPair -> Term .
  eq extractBinding( {V <- Trm , Ctxt} ) = Trm .

  
***	 {[e,g] a [f,h],[e,g] a [f,h]} >['acc]> ({[e,g],[e,g]} a {[f,h],[f,h]})
	
	op nn : ResultTriple -> Term .
	
	op getR : Term -> Term .
	eq getR( '_>`[_`]>_[Trm, Q, Trm1] ) = Q .
	eq getR ( Trm ) = empty .
	
	op align : Term Term Term -> Term .
    ceq align( Trm, Trm1, Trm2 ) = '_>`[_`]>_[matchbt(Trm,Trm1,0,0), getR(Trm1),Trm2]
		if matchbt(Trm,Trm1,0,0) =/= empty .
	eq align( Trm, Trm1, Trm2 ) = empty .
	eq align( Trm, empty, Trm2 ) = empty .
	
	op align1 : Term Term Term -> Term .
    eq align1( Trm, Trm1, Trm2 ) = '_>`[_`]>_[matchbt(Trm,Trm1,0,0), getR(Trm1),Trm2] .
	


	
	***reduce in SAM-Meta : downTerm(path(upTerm({[a,c],[e,g]} >['n]> [{a,[e,g]},{c,[e,g]}])),E:Structure) .
	
	op matchbt : Term Term Nat Nat -> Term .
	eq matchbt( Trm, '_>`[_`]>_[Trm1,Q,Trm2], N , K) = 
			*** search for deeper derivations inside the "searched path"
			if metaXmatch(['SAM-Meta], '_>`[_`]>_['Phi1:DerivStructure,'Phi2:Qid,'Phi3:DerivStructure], Trm1, nil , 0, unbounded, N) =/= noMatch then
				*** match every possible part of the Trm
				if metaXmatch(['SAM-Meta], 'S:Structure, Trm, nil, 0, unbounded,K) =/= noMatch then
					*** get the matched deeper derivation and check if the bottom formula of it matches the part of Trm
					if getFormula(substitute('_>`[_`]>_['Phi1:DerivStructure,'Phi2:Qid,'Phi3:DerivStructure], getSubstitution(metaXmatch(['SAM-Meta], '_>`[_`]>_['Phi1:DerivStructure,'Phi2:Qid,'Phi3:DerivStructure], Trm1, nil , 0, unbounded, N))))
						== extractBinding(getSubstitution(metaXmatch(['SAM-Meta], 'S:Structure, Trm, nil, 0, unbounded,K))) then
							*** check if the topFormulas are equal... leave it for now...
									*** then replace the part of Trm with the deeper derivation, and call whole thing again in case there are multiple cases
									*** had to replace chosen derivation in trm1 with 'a.Atom so that the same derivation doesn't get rechosen
									matchbt(
										replaceContext(getContext(metaXmatch(['SAM-Meta], 'S:Structure, Trm, nil, 0, unbounded,K)),								
													substitute('_>`[_`]>_['Phi1:DerivStructure,'Phi2:Qid,'Phi3:DerivStructure],
															getSubstitution(metaXmatch(['SAM-Meta], '_>`[_`]>_['Phi1:DerivStructure,'Phi2:Qid,'Phi3:DerivStructure], Trm1, nil , 0, unbounded, N)))),
											'_>`[_`]>_[replaceContext(getContext(metaXmatch(['SAM-Meta], '_>`[_`]>_['Phi1:DerivStructure,'Phi2:Qid,'Phi3:DerivStructure], Trm1, nil , 0, unbounded, N)),
															'a.Atom),
														Q,Trm2],
											0,
											0)
										
					else
						matchbt(Trm, '_>`[_`]>_[Trm1,Q,Trm2], N, K + 1)
					fi
				else
					matchbt(Trm, '_>`[_`]>_[Trm1,Q,Trm2], N + 1, 0)
				fi
			else
				Trm
			fi .
	
	eq matchbt(Trm, Trm1,  N, K) = empty .
		
	*** reduce in SAM-Meta : downTerm(path(upTerm( (({[a,c],[e,g]} >['n]> S:Structure) a ({[b,d],[f,h]} >['n]> T:Structure)) >['n]> [({a,[e,g]} a {b,[f,h]}),({c,[e,g]} a {d,[f,h]})] )),E:Structure) .

			

	op mpp : ResultTriple -> Term .
	op n : Nat -> Term .
	***THIS
	***reduce in SAM-Meta : downTerm(path(upTerm( (({[a,c],[e,g]} >['n]> S:Structure) a ({[b,d],[f,h]} >['n]> T:Structure)) >['n]> [({a,[e,g]} a {b,[f,h]}),({c,[e,g]} a {d,[f,h]})] )),E:Structure) .
	
	***reduce in SAM-Meta : downTerm(path(upTerm({[a,c],[e,g]} >['n]> [{a,[e,g]},{c,[e,g]}])), E:Structure) .
	***reduce in SAM-Meta : downTerm(path(upTerm([c a a,d a b] >['n]> Phi1:Structure >['n]> 'Phi2:Structure >['n]> ([c,d] a [a,b]))),E:Structure) .
	

	op path : Term -> Term .
	op path : Term Nat TermList -> Term .
	op path : Term Nat -> Term .
	op path1 : Term Nat -> Term .
	op path2 : Term Nat -> Term .
	op pathadd : Term Nat -> Term .
	
	***THIS :) I just need to make it work better...
	***reduce in SAM-Meta : downTerm(path(upTerm((({[[e,g],[e,g]],[a,c]} >['n]> S:Structure) a ({[[f,h],[f,h]],[b,d]} >['n]> S:Structure)) >['n]> [({a,P1:Structure} a {b,P2:Structure}) >['n]> {a a b,P8:Structure a P7:Structure} , ({c,P3:Structure} a {d,P4:Structure}) >['n]> {c a d,P5:Structure a P6:Structure} ] >['n]> {[a a b,c a d],{P9:Structure a P10:Structure,P11:Structure a P12:Structure} >['n]> ( (P13:Structure >['n]> [e,g]) a (P14:Structure >['n]> [f,h]) ) >['n]> [e a f,g a h] }), 0),E:Structure) .
	
	
	
	op q : Trace -> Term .
	
	op getF : TermList -> Term .
	eq getF( (Trm,TL) ) = Trm .
	eq getF( Trm ) = Trm .
	
	op getS : TermList -> Term .
	eq getS( (TL,Trm) ) = Trm .
	eq getS( Trm ) = Trm .
	
	op loop : Term Nat TermList -> Term .
	
	op jj : ResultTriple -> Term .
	
	eq loop( '_>`[_`]>_[ Trm, Q, Trm1 ], N, empty) = empty . 
	
	eq loop( '_>`[_`]>_[ Trm, Q, Trm1 ], N, (Trm2,TL)  ) = 
		if metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N ) =/= failure then
					if path(substitute( Trm1 , getSubstitution(metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N ))),0) =/= empty then
						align(
							Trm2,
							pathit(metaSearchPath(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N),
										 substitute( Trm1 , getSubstitution(metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N )))),
							path(substitute( Trm1 , getSubstitution(metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N ))),0)
						), loop('_>`[_`]>_[ Trm, Q, Trm1 ], N + 1, (Trm2,TL))
						
					else
						loop('_>`[_`]>_[ Trm, Q, Trm1 ], N + 1, (Trm2,TL))
					fi
			else
				loop('_>`[_`]>_[ Trm, Q, Trm1 ], 0, TL) *** try next in the list, if no more in list then empty 
			fi .
			
	op loop1 : Term Nat TermList -> Term .
	eq loop1( '_>`[_`]>_[ Trm, Q, Trm1 ], N, empty) = empty . 
	eq loop1( '_>`[_`]>_[ Trm, Q, Trm1 ], N, (Trm2,TL)  ) = 
		if metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N ) =/= failure then
					if path1(substitute( Trm1 , getSubstitution(metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N ))),0) =/= empty then
						align(
							Trm2,
							pathit(metaSearchPath(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N),
										 substitute( Trm1 , getSubstitution(metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N )))),
							path1(substitute( Trm1 , getSubstitution(metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N ))),0)
						), loop1('_>`[_`]>_[ Trm, Q, Trm1 ], N + 1, (Trm2,TL))
					else
						loop1('_>`[_`]>_[ Trm, Q, Trm1 ], N + 1, (Trm2,TL))
					fi
			else
				loop1('_>`[_`]>_[ Trm, Q, Trm1 ], 0, TL) *** try next in the list, if no more in list then empty 
			fi .
			
	op loop2 : Term Nat TermList -> Term .
	eq loop2( '_>`[_`]>_[ Trm, Q, Trm1 ], N, empty) = empty . 
	eq loop2( '_>`[_`]>_[ Trm, Q, Trm1 ], N, (Trm2,TL)  ) =
		if metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N ) =/= failure then
					if path2(substitute( Trm1 , getSubstitution(metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N ))),0) =/= empty then
						align(
							Trm2,
							pathit(metaSearchPath(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N),
										 substitute( Trm1 , getSubstitution(metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N )))),
							path2(substitute( Trm1 , getSubstitution(metaSearch(['SAM-Meta], getTopFormula(Trm2), getFormula(Trm1), nil, '+, 1, N ))),0)
						), loop2('_>`[_`]>_[ Trm, Q, Trm1 ], N + 1, (Trm2,TL))
					else
						loop2('_>`[_`]>_[ Trm, Q, Trm1 ], N + 1, (Trm2,TL))
					fi
			else
				loop2('_>`[_`]>_[ Trm, Q, Trm1 ], 0, TL) *** try next in the list, if no more in list then empty 
			fi .

	 
	eq path( '_>`[_`]>_[ Trm, Q, Trm1 ], N ) =
		loop( '_>`[_`]>_[ Trm, Q, Trm1 ], N, path(Trm,0)) .
			
	eq path1( '_>`[_`]>_[ Trm, Q, Trm1 ], N ) =
		loop1( '_>`[_`]>_[ Trm, Q, Trm1 ], N, path1(Trm,0)) .
	
	eq path2( '_>`[_`]>_[ Trm, Q, Trm1 ], N ) =
		loop2( '_>`[_`]>_[ Trm, Q, Trm1 ], N, path2(Trm,0)) .
			
	ceq path2( '___[ Trm, cnst, Trm1 ], N ) = unpack(path2(Trm,N), cnst, path2(Trm1, N), N, path2(Trm,N))
		if path2(Trm, N) =/= empty /\ path2(Trm1, N) =/= empty .
	eq path2( '___[ Trm, cnst, Trm1 ], N ) = empty .
	
	ceq path2( op [ Trm, TL ], N ) = op[ path2(Trm, N) , path2(TL, N) ] 
		if TL =/= empty /\  path2(Trm, N) =/= empty /\ path2(TL, N) =/= empty .
	ceq path2( op[ Trm, TL ], N ) = empty
		if TL =/= empty .
	
	ceq path2( (Trm, TL), N ) = path2(Trm, N), path2(TL, N)
		if TL =/= empty .
	eq path2( Trm, N ) = Trm .
	
	
	ceq path1( '___[ Trm, cnst, Trm1 ], N ) = unpack(path1(Trm,N), cnst, path1(Trm1, N), N, path1(Trm,N))
		if path1(Trm, N) =/= empty /\ path1(Trm1, N) =/= empty .
	eq path1( '___[ Trm, cnst, Trm1 ], N ) = empty .
	
	ceq path1( op [ Trm, TL ], N ) = op[ path1(Trm, N) , path1(TL, N) ] 
		if TL =/= empty /\  path1(Trm, N) =/= empty /\ path1(TL, N) =/= empty .
	ceq path1( op[ Trm, TL ], N ) = empty
		if TL =/= empty .
	
	ceq path1( (Trm, TL), N ) = path1(Trm, N), path1(TL, N)
		if TL =/= empty .
	eq path1( Trm, N ) = Trm .
	
	ceq path( '___[ Trm, cnst, Trm1 ], N ) = unpack(path(Trm,N), cnst, path(Trm1, N), N, path(Trm,N))
		if path(Trm, N) =/= empty /\ path(Trm1, N) =/= empty .
	eq path( '___[ Trm, cnst, Trm1 ], N ) = empty .
	
	ceq path( op [ Trm, TL ], N ) = op[ path(Trm, N) , path(TL, N) ] 
		if TL =/= empty /\  path(Trm, N) =/= empty /\ path(TL, N) =/= empty .
	ceq path( op[ Trm, TL ], N ) = empty
		if TL =/= empty .
	
	ceq path( (Trm, TL), N ) = path(Trm, N), path(TL, N)
		if TL =/= empty .
	eq path( Trm, N ) = Trm .
	
	op unpack : TermList Term TermList Nat TermList -> TermList .
	eq unpack( (Trm,TL), cnst, (Trm1,TL1), N, (Trm2,TL2)) = '___[Trm, cnst, Trm1] , unpack( TL, cnst, (Trm1, TL1) ,N, (Trm2,TL2)) .
	eq unpack( (Trm,TL), cnst, empty, N, (Trm2,TL2)) = empty .
	eq unpack( empty, cnst, (Trm1,TL1), N, (Trm2,TL2) ) = unpack((Trm2,TL2), cnst, TL1, N, (Trm2,TL2)) .
	eq unpack( empty, cnst, empty, N, (Trm2,TL2) ) = empty .
	

	op pathit : Trace Term -> Term .
    eq pathit( Tr, finalTrm ) = testit(Tr, finalTrm) .
	
	
	op testit : Trace Term -> Term .
	op testit : Trace Term Term -> Term .
	op testit : Trace Term Rule Term Nat Term Nat -> Term .
	
	eq testit( TrSt1 TrSt2 Tr, finalTrm) = testit(TrSt1 TrSt2 Tr, getTerm(TrSt1), getRule(TrSt1), getTerm(TrSt2), 0, finalTrm, 0 ) .
	eq testit( TrSt1 Tr, finalTrm ) = testit(TrSt1 Tr, getTerm(TrSt1), getRule(TrSt1), finalTrm, 0, finalTrm , 0) .
	
	eq testit( TrSt1 TrSt2 Tr, Trm, finalTrm ) = testit(TrSt1 TrSt2 Tr, Trm, getRule(TrSt1), getTerm(TrSt2), 0, finalTrm, 0 ) .
	eq testit( TrSt1 Tr, Trm, finalTrm ) = testit(TrSt1 Tr, Trm, getRule(TrSt1), finalTrm, 0, finalTrm, 0 ) .
	
	eq testit( nil, finalTrm ) = finalTrm .
	eq testit( nil, Trm, finalTrm ) = Trm .

	eq testit( TrSt Tr , Trm1, Rle, Trm2, N, finalTrm , K) =
		if metaXmatch(['SAM-Meta], getPr(Rle) , getTopFormula(Trm1), nil , 0, unbounded, N) =/= noMatch then 
			if 	getTopFormula(
						replaceContext(getContext(metaXmatch(['SAM-Meta], getPr(Rle), getTopFormula(Trm1), nil , 0, unbounded, N)),
										'_>`[_`]>_[substitute(getPr(Rle), getSubstitution(metaXmatch(['SAM-Meta], getPr(Rle), getTopFormula(Trm1), nil , 0, unbounded, N))) ,
													upTerm(rulename(Rle)),
													substitute(getCo(Rle), getSubstitution(metaXmatch(['SAM-Meta], getPr(Rle), getTopFormula(Trm1), nil , 0, unbounded, N)))]))
				== getFormula(Trm2)
			then
					if metaXmatch(['SAM-Meta], 'Phi1:DerivStructure , Trm1 ,nil, 0, unbounded, K) =/= noMatch then
							if flatten(getTopFormula(extractBinding(getSubstitution(metaXmatch(['SAM-Meta], 'Phi1:DerivStructure , Trm1 ,nil,0, unbounded, K)))))
								== flatten(substitute(getPr(Rle), getSubstitution(metaXmatch(['SAM-Meta], getPr(Rle) , getTopFormula(Trm1), nil , 0, unbounded, N))))
							then
								testit( Tr,
										replaceContext(getContext(metaXmatch(['SAM-Meta], 'Phi1:DerivStructure , Trm1 ,nil,0, unbounded, K)),
														'_>`[_`]>_[extractBinding(getSubstitution(metaXmatch(['SAM-Meta], 'Phi1:DerivStructure , Trm1 ,nil,0, unbounded, K))),
																	upTerm(rulename(Rle)),
																	substitute(getCo(Rle), getSubstitution(metaXmatch(['SAM-Meta], getPr(Rle) , getTopFormula(Trm1), nil , 0, unbounded, N)))]),
										finalTrm)
							else
								testit( TrSt Tr , Trm1, Rle, Trm2, N, finalTrm , K + 1)
							fi
					else
						empty
					fi
			else
				testit( TrSt Tr , Trm1, Rle, Trm2, N + 1 , finalTrm, 0 )
			fi 
			
		else
			empty
		fi .
													
	op n : Trace -> Term .									
	
 	op getPr : Rule -> Term .
	eq getPr( crl Trm => Trm1 if Cond [Attrs]. ) = Trm .
	eq getPr( rl Trm => Trm1 [Attrs]. ) = Trm .
	op getCo : Rule -> Term .
	eq getCo( crl Trm => Trm1 if Cond [Attrs]. ) = Trm1 .
	eq getCo( rl Trm => Trm1 [Attrs]. ) = Trm1 .
	
	op replaceContext : Context Term -> Term .
	eq replaceContext ( op [ TL , con, TL1 ], Trm3 ) = op [ TL , replaceContext ( con, Trm3 ) , TL1 ] .
	eq replaceContext ( [] , Trm3 ) = Trm3 .
	
	op substitute : Term Substitution -> Term .
	ceq substitute( op [ Trm , TL ], Subst ) = op [ substitute( Trm, Subst ) , substitute( TL, Subst ) ]
		if TL =/= empty .
	ceq substitute( (Trm, TL), Subst ) = substitute( Trm, Subst ), substitute( TL, Subst )
		if TL =/= empty .
	eq substitute( Trm , V <- Trm2 ; Subst ) =
		if Trm == V then 
			Trm2
		else
			substitute( Trm, Subst )
		fi .
	eq substitute( Trm , none ) = Trm .
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

								
										
										
   op getRe : RewritingSet Term -> RewritingSet .
   op getRe : RewritingSet Term Nat -> RewritingSet .
   op getRe1 : RewritingSet Term -> RewritingSet .
  
   eq getRe( (rewriting( Q , Ctxt, Trm1, OrigTrm, Subst) , ReingList) , Trm2 , N ) =
	if interpret(Trm1) == Trm2 then
		rewriting( upTerm(Q) , Ctxt, Trm1, OrigTrm, Subst )
	else
		getRe( ReingList , Trm2 )
	fi .
  
  eq getRe( (rewriting( Q , Ctxt, Trm1, OrigTrm, Subst ) , ReingList) , Trm2 ) =
	if Trm1 == Trm2 then
		rewriting( upTerm(Q) , Ctxt, Trm1, OrigTrm, Subst)
	else
		getRe( ReingList , Trm2 )
	fi .
	
  eq getRe1( (rewriting( Q , Ctxt, Trm1, OrigTrm, Subst ) , ReingList) , Trm2 ) =
	if getTopFormula(Trm1) == Trm2 then
		rewriting( upTerm(Q) , Ctxt, Trm1, OrigTrm, Subst)
	else
		getRe1( ReingList , Trm2 )
	fi .
  
  
  eq getRe (empty , Trm2 ) = empty .
  eq getRe1( empty, Trm2 ) = empty .
 
  op tracestep2deriv : TraceStep Term -> Term .
  eq tracestep2deriv({Trm, Tp, Rle}, Trm1) = '_>`[_`]>_[Trm, upTerm(rulename(Rle)), Trm1] .
  
  op getTerm : TraceStep -> Term .
  eq getTerm( { Trm , Tp, Rle } ) = Trm .
  
  op getTerm : Trace -> Term .
  eq getTerm( (TrSt Tr) ) = getTerm(Tr) .
  
  op getType : TraceStep -> Type .
  eq getType( { Trm , Tp, Rle } ) = Tp .
   
  var Cond : Condition .
  op rulename : Rule -> Qid .
  op rulename : AttrSet -> Qid . 
  eq rulename(rl Trm => Trm2 [Attrs].)          = rulename(Attrs) .
  eq rulename(crl Trm => Trm2 if Cond [Attrs].) = rulename(Attrs) .
  eq rulename(label(Q) Attrs)                   = Q .
  
  op getRule : TraceStep -> Rule .
  eq getRule( { Trm , Tp, Rle } ) = Rle .
  
  sorts TraceList .
  subsorts Trace < TraceList .
  op empty : -> TraceList [ctor] .
  op _,_ : TraceList TraceList -> TraceList [ctor assoc id: empty gather (e E) prec 121] .
  op _[_] : Qid TraceList -> Trace [ctor] .
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

endfm